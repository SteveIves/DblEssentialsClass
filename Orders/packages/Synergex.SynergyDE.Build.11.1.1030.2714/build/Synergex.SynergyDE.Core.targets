<!--
***********************************************************************************************
Synergex.SynergyDE.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process specific for Synergy .NET projects.
For example, it contains the step that actually calls the dblnet compiler.  The remainder
of the build process is defined in Microsoft.Common.targets, which is imported by 
this file.

Copyright (C) Synergex Corporation. All rights reserved.
***********************************************************************************************
-->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <NetCoreStandard Condition="'$(NetCoreStandard)' == ''">false</NetCoreStandard>
  </PropertyGroup>

  <PropertyGroup>
    <!--
      Synergy.NET Tasks for .NET Core
      Designed for consumption from a nuget package, the Tasks assembly for .NET Core is located in the tools directory of the package.
    -->
    <_TasksAssembly Condition="'$(NetCoreStandard)' == 'true'">$(MSBuildThisFileDirectory)..\tools\dbl\SynergyTasks.Core.dll</_TasksAssembly>
    <_TasksAssembly Condition="'$(PackageModel)' == 'true'">$(MSBuildThisFileDirectory)..\tools\dbl\SynergyTasks.Core.dll</_TasksAssembly>
    <!--
      Synergy.NET Tasks for .NET Framework
      The Tasks assembly for .NET Framework is always located and available from $(MSBuildExtensionsPath)\Synergex\dbl\    
    -->
    <_TasksAssembly Condition="'$(_TasksAssembly)' == ''">$(MSBuildExtensionsPath)\Synergex\dbl\SynergyTasks.dll</_TasksAssembly>
  </PropertyGroup>

  <UsingTask TaskName="SynergyTasks.DBR" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.CreateDBLManifestResourceName" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.IncludeDependencyTask" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.InteropCodeGen" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.PEVerifyTask" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.TaskOutputPredictor" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.EvaluateCompileFiles" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.DependencyEvaluation.WriteCache" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.DependencyEvaluation.EvaluateCache" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.ResolveReferences" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.FilterSynergyProjects" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.SplitReferencePaths" AssemblyFile="$(_TasksAssembly)"/>

  <!--
    <PropertyGroup>
       <ImportByWildcardBeforeMicrosoftCSharpTargets Condition="'$(ImportByWildcardBeforeMicrosoftCSharpTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCSharpTargets>
       <ImportByWildcardAfterMicrosoftCSharpTargets Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == ''">true</ImportByWildcardAfterMicrosoftCSharpTargets>
    </PropertyGroup>
-->
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\$(MSBuildThisFile)\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\$(MSBuildThisFile)\ImportBefore')"/>

  <PropertyGroup>
    <EnableCommonProperties Condition="'$(EnableCommonProperties)' == ''">False</EnableCommonProperties>
    <CommonPropertiesInputs></CommonPropertiesInputs>
    <CommonPropertiesInputs Condition="$(EnableCommonProperties)">$(CommonPropertiesFileLocation)</CommonPropertiesInputs>
  </PropertyGroup>

  <!--
    The CreateManifestResourceNames target create the manifest resource names from the .RESX
    files.
    
        [IN]
        @(EmbeddedResource) - The list of EmbeddedResource items that have been pre-processed to add metadata about resource type
                              Expected Metadata "Type" can either be "Resx" or "Non-Resx"

        [OUT]
        @(EmbeddedResource) - EmbeddedResource items with metadata         
        
    For C# applications the transformation is like:

        Resources1.resx => RootNamespace.Resources1 => Build into main assembly
        SubFolder\Resources1.resx => RootNamespace.SubFolder.Resources1 => Build into main assembly
        Resources1.fr.resx => RootNamespace.Resources1.fr => Build into satellite assembly
        Resources1.notaculture.resx => RootNamespace.Resources1.notaculture => Build into main assembly

    For other project systems, this transformation may be different.
    -->
  <Target
      Name="CreateManifestResourceNames"
      Condition="'@(EmbeddedResource)' != ''"
      DependsOnTargets="$(CreateManifestResourceNamesDependsOn)">

    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>

    <!-- Create manifest names for culture and non-culture Resx files, and for non-culture Non-Resx resources -->
    <SynergyTasks.CreateDBLManifestResourceName
          ResourceFiles="@(EmbeddedResource)"
          RootNamespace="$(RootNamespace)"
          Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">

      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />

    </SynergyTasks.CreateDBLManifestResourceName>

    <!-- Create manifest names for all culture non-resx resources -->
    <SynergyTasks.CreateDBLManifestResourceName
          ResourceFiles="@(EmbeddedResource)"
          RootNamespace="$(RootNamespace)"
          PrependCultureAsDirectory="false"
          Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">

      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />

    </SynergyTasks.CreateDBLManifestResourceName>

    <ItemGroup>
      <EmbeddedResource Remove="@(EmbeddedResource)" Condition="'%(EmbeddedResource.ManifestResourceName)' == ''"/>
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>

  </Target>

  <PropertyGroup>
    <Language>Synergy</Language>
    <DebugSymbols>true</DebugSymbols>
    <CoreCompileDependsOn>
      PreBuildEventWithInputs;
      _ComputeNonExistentFileProperty;
      CompileDetection;
      PredictIncludeDependencies;
      _ComputeDependencyHashesRequireBuild
    </CoreCompileDependsOn>
    <ExportWinMDFile Condition="'$(ExportWinMDFile)' == '' and '$(OutputType)' == 'WinMDObj'">true</ExportWinMDFile>
    <OutputPlatform Condition="'$(OutputPlatform)' == '' and ('$(OutputType)' == 'AppContainerExe' or '$(OutputType)' == 'winmdobj')">32bitpreferred</OutputPlatform>
    <OutputPlatform Condition="'$(OutputPlatform)' == ''">$(PlatformTarget)</OutputPlatform>
    <CombinedEnvVars>$(CommonEnvVars);$(ProjEnvVars)</CombinedEnvVars>
    <RunVerifyPostTarget Condition=" '$(RunVerifyPostCompile)' == 'True' OR '$(RunVerifyPostCompile)' == 'true' ">CopyFilesToOutputDirectory</RunVerifyPostTarget>
    <CompilationDetected>false</CompilationDetected>
  </PropertyGroup>

  <PropertyGroup>
    <PreBuildEventWithInputsDependsOn></PreBuildEventWithInputsDependsOn>
  </PropertyGroup>
  <Target Name="PreBuildEventWithInputs"
          Condition="'$(PreBuildEvent)' != '' and '$(RunPreBuildEvent)' == 'Content'"
          DependsOnTargets="$(PreBuildEventWithInputsDependsOn)"
          Inputs="@(Content)"
          Outputs="$(TargetPath)">
    <Exec WorkingDirectory="$(OutDir)" Command="$(PreBuildEvent)" />
  </Target>

  <Target Name="SynergyNugetRestore"
          Condition="'$(NetCoreStandard)' == 'true' and '$(ResolvePackageDependenciesForBuild)' == 'true' and Exists('$(ProjectAssetsFile)')"
	        BeforeTargets="ResolvePackageDependenciesForBuild">
    <CallTarget Targets="restore"/>
  </Target>

  <Target
      Name="CompileDetection"
      Inputs="$(MSBuildAllProjects);
                @(Compile);
                @(GeneratedFiles);
                @(_CoreCompileResourceInputs);
                $(ApplicationIcon);
                $(AssemblyOriginatorKeyFile);
                @(ReferencePath);
                @(CompiledLicenseFile);
                @(LinkResource);
                @(EmbeddedDocumentation); 
                $(Win32Resource);
                $(Win32Manifest);
                @(CustomAdditionalCompileInputs);
                $(RPSOutputs);
                $(CommonPropertiesInputs)"
        Outputs="@(DocFileItem);
                 @(IntermediateAssembly);
                 @(_DebugSymbolsIntermediatePath);
                 $(NonExistentFile);
                 @(CustomAdditionalCompileOutputs)"
      >

    <CreateProperty Value="true">
      <Output TaskParameter="ValueSetByTask"
        PropertyName="CompilationDetected" />
    </CreateProperty>
  </Target>

  <Target
       Name="PredictIncludeDependencies"
       Returns="IncludeFileDependencies"
       BeforeTargets="CoreCompile"
    >

    <SynergyTasks.IncludeDependencyTask
      CompileSingle="True"
      SourceFiles="@(Compile)"
      OutputDirectory="$(IntermediateOutputPath)"
      OutputAssembly="@(IntermediateAssembly)"
      ProjectName="$(ProjectName)"
      OutputItems="@(IncludeFileDependencies)">

      <Output ItemName="IncludeFileDependencies" TaskParameter="OutputItems" />
    </SynergyTasks.IncludeDependencyTask>

    <PropertyGroup>
      <IncludeInputs>@(IncludeFileDependencies)</IncludeInputs>
    </PropertyGroup>
  </Target>

  <!--
    ===========================================================================
                              _ComputeCoreCompileInputs
    ===========================================================================
      Generates the CoreCompileInputs property that determines the list of
      inputs used for dependency evaluation by the CoreCompile target.
      
      The primary function of this target is to gate CoreCompile's dependency
      on reference library inputs behind the _DependencyHashesRequireBuild flag.
      By doing this, we only build based on dependencies when requisite signatures
      have changed
  -->

  <Target Name="_ComputeCoreCompileInputs"
          DependsOnTargets="_ComputeDependencyHashesRequireBuild;_SplitReferencePaths">
    <PropertyGroup>
      <CoreCompileInputs>
        $(MSBuildAllProjects);
        @(Compile);
        @(GeneratedFiles);
        @(_CoreCompileResourceInputs);
        $(ApplicationIcon);
        $(AssemblyOriginatorKeyFile);
        @(CompiledLicenseFile);
        @(LinkResource);
        @(EmbeddedDocumentation);
        $(Win32Resource);
        $(Win32Manifest);
        $(IncludeInputs);
        @(CustomAdditionalCompileInputs);
        $(RPSOutputs);
        $(CommonPropertiesInputs)
        @(NonSynergyReferences)
      </CoreCompileInputs>
      <CoreCompileInputs Condition="'$(_DependencyHashesRequireBuild)' == 'True'">$(CoreCompileInputs);@(SynergyReferences)</CoreCompileInputs>
    </PropertyGroup>
  </Target>

  <!--
    Target: CoreCompile
      This is the primary target for compiling a Synergy program
  -->
  <Target
        Name="CoreCompile"
        Inputs="$(CoreCompileInputs)"
        Outputs="@(DocFileItem);
                 @(IntermediateAssembly);
                 @(_DebugSymbolsIntermediatePath);
                 $(NonExistentFile);
                 @(CustomAdditionalCompileOutputs)"
        Returns=""
        DependsOnTargets="$(CoreCompileDependsOn);RPSTaskOutputPredictor;CheckCompileFiles;_ComputeCoreCompileInputs"
    >

    <PropertyGroup>
      <!-- If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
			   then we'll use AppConfig -->
      <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' and '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>
      <SynergyNoSTDLib Condition="'$(NetCoreStandard)'">true</SynergyNoSTDLib>
      <SynergyNoSTDLib Condition="'$(SynergyNoSTDLib)' == ''">false</SynergyNoSTDLib>
      <SynergyPortable Condition="'$(SynergyPortable)' == ''">false</SynergyPortable>
      <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
      <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
    </PropertyGroup>

    <SynergyTasks.DBR
      NoSTDLib ="$(SynergyNoSTDLib)"
			AppxPackage ="$(AppxPackage)"
			OutputAssembly="@(IntermediateAssembly)"
			OutputDirectory="$(OutputPath)"
      IntermediateOutputPath="$(IntermediateOutputPath)"
			SourceFiles="@(Compile)"
			ResourceFiles="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)"
			ReferencedAssemblies="@(ReferencePath)"
      RPSReference="@(RPSFileReferences)"
      ProjectReferences="@(_MSBuildProjectReferenceExistent)"
			Configuration="$(Configuration)"
			DFlags="$(DBLCmdOptions)"
			LFlags="$(DBLinkCmdOptions)"
			TargetKind="$(OutputType)"
			StrongNameKeyFile="$(KeyOriginatorFile)"
			DelaySigned="$(DelaySign)"
			TargetFramework="$(TargetFrameworkVersion)"
      DocumentFile="$(DocumentationFile)"
      DebugOptimizeCode="$(DebugOptimize)"
      DLLBaseAddress="$(DllBaseAddress)"
      Platform="$(OutputPlatform)"
      EnvironmentVars="$(CombinedEnvVars)"
      RootNS="$(RootNamespace)"
      AppIcon="$(ApplicationIcon)"
      ResType="$(ResourceType)"
      ResName="$(ResourceName)"
      NoWin32Manifest="$(NoWin32Manifest)"
      TargetRuntimeLevel="$(TargetRuntimeLevel)"
      Portable="$(SynergyPortable)"
      NetCoreStandard="$(NetCoreStandard)"
      ContentFiles="@(Content)"
      Prefer32Bit="$(Prefer32Bit)"
      DBL_qDefineOpt="$(DBL_qDefineOpt)"
      TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
			/>
  </Target>

  <Target
        Name="XamlPreCompile"
        Inputs="$(MSBuildAllProjects);
                @(Compile);
                @(_CoreCompileResourceInputs);
                $(ApplicationIcon);
                $(AssemblyOriginatorKeyFile);
                @(ReferencePath);
                @(CompiledLicenseFile);
                @(LinkResource);
                @(EmbeddedDocumentation); 
                $(Win32Resource);
                $(Win32Manifest);
                @(CustomAdditionalCompileInputs);
                @(Page);
                @(ApplicationDefinition);
                $(RPSOutputs);
                $(CommonPropertiesInputs)"
                  
        Outputs="@(DocFileItem);
                 @(XamlIntermediateAssembly);
                 @(_DebugSymbolsIntermediatePath);
                 $(NonExistentFile);
                 @(CustomAdditionalCompileOutputs)"
        Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != ''"
        Returns=""
        DependsOnTargets="$(CoreCompileDependsOn);RPSTaskOutputPredictor"
    >

    <PropertyGroup>
      <!--
        If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
			  then we'll use AppConfig
      -->
      <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' and '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>

      <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
      <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
    </PropertyGroup>

    <SynergyTasks.DBR
			AppxPackage="$(AppxPackage)"
			OutputAssembly="@(XamlIntermediateAssembly)"
			OutputDirectory="$(OutputPath)"
      IntermediateOutputPath="$(IntermediateOutputPath)"
			SourceFiles="@(Compile)"
			ResourceFiles="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)"
			ReferencedAssemblies="@(ReferencePath)"
      RPSReference="@(RPSFileReferences)"
      ProjectReferences="@(_MSBuildProjectReferenceExistent)"
			Configuration="$(Configuration)"
			DFlags="$(DBLCmdOptions)"
			LFlags="$(DBLinkCmdOptions)"
			TargetKind="$(OutputType)"
			StrongNameKeyFile="$(KeyOriginatorFile)"
			DelaySigned="$(DelaySign)"
			TargetFramework="$(TargetFrameworkVersion)"
      DocumentFile="$(DocumentationFile)"
      DebugOptimizeCode="$(DebugOptimize)"
      DLLBaseAddress="$(DllBaseAddress)"
      Platform="$(OutputPlatform)"
      EnvironmentVars="$(CombinedEnvVars)"
      RootNS="$(RootNamespace)"
      AppIcon="$(ApplicationIcon)"
      ResType="$(ResourceType)"
      ResName="$(ResourceName)"
      NoWin32Manifest="$(NoWin32Manifest)"
      TargetRuntimeLevel="$(TargetRuntimeLevel)"
      Portable="$(SynergyPortable)"
      NetCoreStandard="$(NetCoreStandard)"
      ContentFiles="@(Content)"
      TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
      DBL_qDefineOpt="$(DBL_qDefineOpt)"
			/>
  </Target>

  <PropertyGroup>
    <GeneratedOutputName>$(Name.Trim('"'))GeneratedFiles.out</GeneratedOutputName>
    <GenerateInteropBeforeCompile Condition="'$(XfplMigration)' != ''">CoreCompile</GenerateInteropBeforeCompile>
  </PropertyGroup>

  <!--
    Target: GenerateInterop
      This target is responsible for executing dbl2xml and genC# to create
      Synergy Interop source files.
    
      For determining execution, the compiled files and references paths are
      used for inputs. The dates on those files are compared against the single
      output, <ProjectName>GeneratedFiles.out, which is modified every time
      this target is executed.
      
      The BeforeTargets indicates that we should be run before the target specified.
      If this project is XFPL enabled, the GenerateInteropBeforeCompile property
      will specify the CoreCompile target.
  -->
  <Target
    Name="GenerateInterop"
    Inputs="$(MSBuildAllProjects);
      @(Compile);
      @(ReferencePath);"
    Outputs="$(GeneratedOutputName)"
    BeforeTargets="$(GenerateInteropBeforeCompile)">

    <SynergyTasks.InteropCodeGen
      ProjectName="$(Name)"
      TargetFramework="$(TargetFrameworkVersion)"
      SourceFiles="@(Compile)"
      ReferencedAssemblies="@(ReferencePath)"
      RootNamespace="$(RootNamespace)"
      IntermediateOutputPath="$(IntermediateOutputPath)"
      TargetRuntimeLevel="$(TargetRuntimeLevel)"
      DBL_qDefineOpt="$(DBL_qDefineOpt)"
      XfplInterop="$(XfplMigration)"
      XfplStrPubFlds="$(XFPL_StrPubFlds)"
      XfplBinFldString="$(XFPL_BinFldString)"
      XfplAltFldNme="$(XFPL_AltFldNme)"
      XfplAltInterface="$(XFPL_AltIntrface)"
      XfplAltInterfaceName="$(XFPL_AltIntrfaceName)"
      XfplPool="$(XFPL_Pool)"
      XfplPoolReturn="$(XFPL_PoolReturn)"
      XfplOutParamType="$(XFPL_OutParamType)"
      XfplWCFContracts="$(XFPL_WCFContracts)"
      XfplSupportMethods="$(XFPL_SupportMethods)"
      XfplGenPropertyChanged="$(XFPL_GenPropertyChanged)"
      XfplGenEmptyConstructor="$(XFPL_GenEmptyConstructor)"
      XfplGenMarshalByRefObject="$(XFPL_GenMarshalByRefObject)"
      XfplGenerateDisposable="$(XFPL_GenerateDisposable)"
      ProjEnvVars="$(CombinedEnvVars)">

      <Output TaskParameter="GeneratedFiles" ItemName="GeneratedFiles" />
      <Output TaskParameter="GeneratedDirectory" ItemName="GeneratedDirectory" />
      <Output TaskParameter="GenFileList" ItemName="GeneratedOutputName" />

    </SynergyTasks.InteropCodeGen>

    <PropertyGroup>
      <GeneratedFiles>$(GeneratedFiles)</GeneratedFiles>
      <GeneratedDirectory>$(GeneratedDirectory)</GeneratedDirectory>
      <GenFileList>$(GenFileList)</GenFileList>
    </PropertyGroup>
  </Target>

  <!--
    Target: CleanInterop
      This target removes the GeneratedCode directory, the generated
      files that are contained in the directory, as well as the listing
      file <ProjectName>GeneratedFiles.out
  -->
  <Target Name="CleanInterop" Condition="'$(XfplMigration)' != ''">
    <CreateItem Include="GeneratedCode\*.*">
      <Output TaskParameter="Include" ItemName="TempGenFiles"/>
    </CreateItem>
    <Delete Files="@(TempGenFiles);$(GeneratedOutputName)"/>
    <RemoveDir Directories="GeneratedCode" />
  </Target>

  <!--
    Target: PEVerify
      This target is responsible for executing peverify.exe on the output assembly and
      returning the results to the user within Visual Studio.
  -->
  <Target
    Name="PEVerify"
    AfterTargets="$(RunVerifyPostTarget)"
    DependsOnTargets="CompileDetection"
    >

    <SynergyTasks.PEVerifyTask
      ProjectName="$(MSBuildProjectName)"
      OutputAssemblies="@(IntermediateAssembly)"
      OutputPath="$(OutputPath)"
      IntermediateOutputPath="$(IntermediateOutputPath)"
      DoVerification="$(CompilationDetected)"
      ProjEnvVars="$(CombinedEnvVars)">

      <Output TaskParameter="ErrorCount" ItemName="ErrorCount" />

    </SynergyTasks.PEVerifyTask>

    <PropertyGroup>
      <ErrorCount>$(ErrorCount)</ErrorCount>
    </PropertyGroup>

  </Target>

  <Target Name="DBLNetClean" BeforeTargets="CoreClean">

    <CreateItem Include="$(IntermediateOutputPath)\*.in">
      <Output TaskParameter="Include" ItemName="TempInputFiles"/>
    </CreateItem>

    <CreateItem Include="$(IntermediateOutputPath)\*.g.dbl">
      <Output TaskParameter="Include" ItemName="TempGeneratedDBLFiles"/>
    </CreateItem>

    <CreateItem Include="$(IntermediateOutputPath)\*.dep">
      <Output TaskParameter="Include" ItemName="TempDepFiles"/>
    </CreateItem>

    <CreateItem Include="$(IntermediateOutputPath)\*.log">
      <Output TaskParameter="Include" ItemName="TempLogFiles"/>
    </CreateItem>

    <CreateItem Include="$(IntermediateOutputPath)\*.out">
      <Output TaskParameter="Include" ItemName="TempOutFiles"/>
    </CreateItem>

    <Delete Files="@(TempInputFiles);@(TempGeneratedDBLFiles);@(TempDepFiles);@(TempLogFiles);@(TempOutFiles)" TreatErrorsAsWarnings="true"/>

  </Target>

  <PropertyGroup>
    <PrepareProjectReferencesDependsOn>$(PrepareProjectReferencesDependsOn);RPSTaskOutputPredictor</PrepareProjectReferencesDependsOn>
  </PropertyGroup>

  <!--
    Import the Microsoft Common targets. This contains most of the MSBuild
    target definitions that our build system relies upon.
  -->
  <PropertyGroup>
    <_CommonTargetsPath Condition="'$(NetCoreStandard)' == 'true'">$(MSBuildBinPath)\Microsoft.Common.targets</_CommonTargetsPath>
    <_CommonTargetsPath Condition="'$(_CommonTargetsPath)' == ''">$(MSBuildToolsPath)\Microsoft.Common.targets</_CommonTargetsPath>
  </PropertyGroup>

  <Import Project="$(_CommonTargetsPath)" />

  <PropertyGroup>
    <IntermediateDBPOutputPath Condition="'$(IntermediateDBPOutputPath)' == ''">$(IntermediateOutputPath)</IntermediateDBPOutputPath>
  </PropertyGroup>
  
  <ItemDefinitionGroup>
    <ProjectReference>
      <!-- Target to build in the project reference; by default, this property is blank, indicating the default targets-->
      <Targets>$(ProjectReferenceBuildTargets)</Targets>
      <!-- Extra item type to emit outputs of the destination into. Defaults to blank. To emit only into this list, set the ReferenceOutputAssembly metadata to false as well. -->
      <OutputItemType/>
      <ReferenceSourceTarget>ProjectReference</ReferenceSourceTarget>
      <RepositoryReference/>
    </ProjectReference>
  </ItemDefinitionGroup>

  <Target
       Name="RPSTaskOutputPredictor"
       Returns="RPSFileReferences"
       BeforeTargets="PrepareProjectReferences"
       DependsOnTargets="AssignProjectConfiguration">

    <SynergyTasks.TaskOutputPredictor
      ReferencedProjects="@(ProjectReferenceWithConfiguration)"
      Target="rps"
      SolutionDir="$(SolutionDir)"
      ProjectName = "$(ProjectName)"
      OutputItems="@(RPSFileReferences)"
      MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
      >

      <Output ItemName="RPSFileReferences" TaskParameter="OutputItems" />
    </SynergyTasks.TaskOutputPredictor>

    <PropertyGroup>
      <RPSOutputs>@(RPSFileReferences)</RPSOutputs>
    </PropertyGroup>
  </Target>

  <!--
    After common targets are defined, overwrite the MainResourcesGeneration target.
    This is a specific fix to a behavior that will not get fixed back in the framework.
  -->
  <Target Name="MainResourcesGeneration" Condition="'@(MainEmbeddedFiles)' != ''">

    <!--
        This generates .resources file containing all the resources that are to be
        embedded in the main assembly and dont need to be localized
    -->

    <Message Text="(in) EmbeddedFiles: '@(MainEmbeddedFiles)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    <ResourcesGenerator
                   ResourceFiles="@(MainEmbeddedFiles)"
                   OutputPath="$(IntermediateOutputPath)"
                   OutputResourcesFile="$(IntermediateOutputPath)$(_ResourceNameInMainAssembly)"
                   Condition="'@(MainEmbeddedFiles)' != ''">

      <!-- Put the generated files in item FileWrites so that they can be cleaned up appropriately in a next Rebuild -->
      <Output ItemName="FileWrites" TaskParameter="OutputResourcesFile" />

    </ResourcesGenerator>

    <ItemGroup>
      <EmbeddedResource Include="$(IntermediateOutputPath)$(_ResourceNameInMainAssembly)">
        <GenerateResource>false</GenerateResource>
        <Type>Resx</Type>
        <WithCulture>false</WithCulture>
        <OutputResource>$(IntermediateOutputPath)$(_ResourceNameInMainAssembly)</OutputResource>
      </EmbeddedResource>
    </ItemGroup>

  </Target>

  <!--
    After common targets are defined, overwrite the meaning of
    "CleanDependsOn". This adds our clean targets to the list of clean
    targets.
  -->
  <PropertyGroup>
    <CleanDependsOn>$(CleanDependsOn)</CleanDependsOn>
    <CleanDependsOn Condition="'$(XfplMigration)' != ''">$(CleanDependsOn);CleanInterop;</CleanDependsOn>
  </PropertyGroup>

  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\$(MSBuildThisFile)\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\$(MSBuildThisFile)\ImportAfter')"/>

  <PropertyGroup>
    <PreBuildEventDependsOn>
      PreBuildEventWithInputs;
      ChangePreBuildEventProperty;
      $(PreBuildEventDependsOn);
    </PreBuildEventDependsOn>
  </PropertyGroup>

  <Target Name="ChangePreBuildEventProperty"
          Condition="'$(RunPreBuildEvent)' == 'Content'">
    <PropertyGroup>
      <PreBuildEvent>echo >nul 2>&amp;1</PreBuildEvent>
    </PropertyGroup>
  </Target>

  <!--Verifies that compile files exist and have extensions. Errors if a file does not exit or have an extension.
    Runs before CoreCompile to ensure good file states for builds.-->
  <Target Name="CheckCompileFiles">
    <EvaluateCompileFiles Files="@(Compile)"/>
  </Target>

  <!--
    ===========================================================================
                              _ComputeDependencyHashesRequireBuild
    ===========================================================================
      In order to validate that a build is actually required based on the
      reference projects, we must compare the known hashes of the reference
      project prototypes against the current hashes of the reference project
      prototypes.
    
      This information will then be summarized as _DependencyHashesRequireBuild
      to indicate to other targets that a build is necessary based on
      dependency hashes or not.
      
      At its simplest, the general dependency flow is:
      needsDependencyBuild = false
      foreach refProject in referenceProjects
        if (cache contains refProject AND cache.storedHash != refProject.hash)
          needsDependencyBuild = true
        
      if (needsDependencyBuild)
        CoreCompileInputs += DependentLibraries
  -->

  <PropertyGroup>
    <_ComputeDependencyHashesRequireBuildDependsOn>
      ResolveReferencePrototypes
    </_ComputeDependencyHashesRequireBuildDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <_DependencyHashesRequireBuild Condition="$(_DependencyHashesRequireBuild) == ''">False</_DependencyHashesRequireBuild>
  </PropertyGroup>

  <Target Name="_ComputeDependencyHashesRequireBuild"
          DependsOnTargets="$(_ComputeDependencyHashesRequireBuildDependsOn)">

    <EvaluateCache Prototypes="@(_ReferenceProjectPrototypes)" CacheFile="$(_DependencyCacheWrites)">
      <Output TaskParameter="RequiresBuild" PropertyName="_DependencyHashesRequireBuild"  />
    </EvaluateCache>
  </Target>


  <!--
    ===========================================================================
                              _WriteDependencyHashCache
    ===========================================================================
      Following a build operation, we need to update this project's dependency
      cache so that subsequent builds can evaluate the cache for each of the
      reference libraries. The hash in the cache is a unique SHA256 of the set
      of signatures inside of the reference library DBP.
  -->

  <PropertyGroup>
    <_DependencyCacheWrites>$(IntermediateOutputPath)DependencyCache.sha256</_DependencyCacheWrites>
    <_WriteDependencyHashCacheDependsOn>
      ResolveReferencePrototypes
    </_WriteDependencyHashCacheDependsOn>
  </PropertyGroup>

  <Target Name="_WriteDependencyHashCache"
          AfterTargets="CoreCompile"
          DependsOnTargets="$(_WriteDependencyHashCacheDependsOn)" >

    <WriteCache Prototypes="@(_ReferenceProjectPrototypes)" CacheFile="$(_DependencyCacheWrites)" />
  </Target>

  <PropertyGroup>
    <ResolveReferencePrototypesDependsOn>
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence;
      _FilterSynergyProjects;
    </ResolveReferencePrototypesDependsOn>
    <_OutputPath>$(OutputPath)</_OutputPath>
  </PropertyGroup>

  <Target Name="_FilterSynergyProjects" Returns="SynergyProjectReferences">
    <FilterSynergyProjects FullProjectReferences="@(_MSBuildProjectReferenceExistent)">
      <Output TaskParameter="SynergyProjectReferences" ItemName="SynergyProjectReferences"/>
    </FilterSynergyProjects>
  </Target>
  
  <Target Name="ResolveReferencePrototypes" DependsOnTargets="$(ResolveReferencePrototypesDependsOn)">
    <MSBuild
      Projects="@(SynergyProjectReferences)"
      Targets="GetPrototypes"
      BuildInParallel="$(BuildInParallel)"
      Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)">
      <Output TaskParameter="TargetOutputs" ItemName="_ReferenceProjectPrototypes"/>
    </MSBuild>
  </Target>

  <!--
    ===========================================================================
                              GetPrototypes
    ===========================================================================
      GetPrototypes is a utility target that is designed to operate within
      MSBuild batch operations and specifically returns a collection of 
      _PrototypeFile items. 
      
      This target is called to resolve the prototypes for referenced projects
      exclusively and follows a pattern of calling MSBuild on a collection of
      project references with specific targets to return results. This technique
      allows for resolving properties of reference projects without performing
      hard project loads inside of C# code.
  -->

  <PropertyGroup>
    <GetPrototypesDependsOn>
      _SetLocalPrototypes;
    </GetPrototypesDependsOn>
  </PropertyGroup>

  <Target Name="GetPrototypes" DependsOnTargets="$(GetPrototypesDependsOn)" Returns="@(_PrototypeFile)">
  </Target>

  <!--
    ===========================================================================
                              _SetLocalPrototypes
    ===========================================================================
      Called as a dependency of GetPrototypes. The primary function of this
      target is to populate a _PrototypeFile item that contains the local
      prototype file generated by this project
      
      A HashFile metadata item gets added to the item for ease of use by the 
      dependency build system.
  -->

  <Target Name="_SetLocalPrototypes">
    <ItemGroup>
      <_PrototypeFile Include="$(IntermediateOutputPath)\$(AssemblyName).dbp" Condition="Exists('$(IntermediateOutputPath)\$(AssemblyName).dbp')">
        <tempPath>$(IntermediateOutputPath)\$(AssemblyName).dbp.sha256</tempPath>
        <HashFile>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)\$(AssemblyName).dbp.sha256'))</HashFile>
      </_PrototypeFile>
    </ItemGroup>
  </Target>
  
  <!--
    ===========================================================================
                              SplitReferencePaths
    ===========================================================================
      Called as a dependency of CoreCompileInputs. The primary function of this
      target is to split between Synergy and non-Synergy references.
  -->

  <Target Name="_SplitReferencePaths">
    <SplitReferencePaths ReferencePath="@(ReferencePath)" ResolvedProjectReferencePaths="@(_ResolvedProjectReferencePaths)">
      <Output TaskParameter="SynergyReferences" ItemName="SynergyReferences"/>
      <Output TaskParameter="NonSynergyReferences" ItemName="NonSynergyReferences"/>
    </SplitReferencePaths>
  </Target>
</Project>
