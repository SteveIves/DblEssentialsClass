<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
    <!--
      Synergy.NET Tasks for .NET Core
      Designed for consumption from a nuget package, the Tasks assembly for .NET Core is located in the tools directory of the package.
    -->
    <_TasksAssembly Condition="'$(PackageModel)' == 'true'">$(MSBuildThisFileDirectory)..\tools\dbl\SynergyTasks.Core.dll</_TasksAssembly>
    <!--
      Synergy.NET Tasks for .NET Framework
      The Tasks assembly for .NET Framework is always located and available from $(MSBuildExtensionsPath)\Synergex\dbl\    
    -->
    <_TasksAssembly Condition="'$(_TasksAssembly)' == ''">$(MSBuildExtensionsPath)\Synergex\dbl\SynergyTasks.dll</_TasksAssembly>
  </PropertyGroup>
  
  <UsingTask TaskName="SynergyTasks.RPS" AssemblyFile="$(_TasksAssembly)"/>
  <UsingTask TaskName="SynergyTasks.ISMExtensioner" AssemblyFile="$(_TasksAssembly)"/>
  <PropertyGroup>
    <OutputPath Condition="'$(OutputPath)' == '' ">$(MSBuildProjectDirectory)\bin\$(Configuration)\$(Platform)</OutputPath>
    <CopyBuildOutputToOutputDirectory>true</CopyBuildOutputToOutputDirectory>
    <CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FileListAbsolute.txt</CleanFile>
    <IntermediateOutputPath>$(MSBuildProjectDirectory)\obj\$(Configuration)\$(Platform)</IntermediateOutputPath>
    <IsRepositoryProject>true</IsRepositoryProject>
    <UpperCombinedReverseEnvVars_>;$(ProjEnvVars.Trim().ToUpper());$(CommonEnvVars.Trim().ToUpper())</UpperCombinedReverseEnvVars_>
    <CombinedReverseEnvVars_>;$(ProjEnvVars.Trim());$(CommonEnvVars.Trim())</CombinedReverseEnvVars_>
    <CombinedEnvVars>;$(CommonEnvVars.Trim());$(ProjEnvVars.Trim())</CombinedEnvVars>
  </PropertyGroup>
  
  <PropertyGroup Condition="'$(UnevaluatedOutputPath)' != ''">
    <UnevaluatedOutputEnvironmentVariablePosition_>$(UnevaluatedOutputPath.IndexOf(':'))</UnevaluatedOutputEnvironmentVariablePosition_>
    <UnevaluatedOutputEnvironmentVariableTrailer_ Condition="'$(UnevaluatedOutputEnvironmentVariablePosition_)' != '' and $(UnevaluatedOutputEnvironmentVariablePosition_) > 2">$(UnevaluatedOutputPath.SubString($([MSBuild]::Add($(UnevaluatedOutputEnvironmentVariablePosition_), 1))))</UnevaluatedOutputEnvironmentVariableTrailer_>
    <UnevaluatedOutputEnvironmentVariable_ Condition="'$(UnevaluatedOutputEnvironmentVariablePosition_)' != '' and $(UnevaluatedOutputEnvironmentVariablePosition_) > 2">$(UnevaluatedOutputPath.Remove($([MSBuild]::Add($(UnevaluatedOutputEnvironmentVariablePosition_), 0))).ToUpper())</UnevaluatedOutputEnvironmentVariable_>
    <CombinedEnvVarEvalPosition_ Condition="'$(UnevaluatedOutputEnvironmentVariable_)' != ''">$(UpperCombinedReverseEnvVars_.IndexOf(";$(UnevaluatedOutputEnvironmentVariable_)="))</CombinedEnvVarEvalPosition_>
    <CombinedEnvVarEvalEqualsPosition_ Condition="'$(UnevaluatedOutputEnvironmentVariable_)' != ''">$(UpperCombinedReverseEnvVars_.IndexOf('=', $([MSBuild]::Add($(CombinedEnvVarEvalPosition_), 2))))</CombinedEnvVarEvalEqualsPosition_>
    <CombinedEnvVarEvalSemicolonPosition_ Condition="'$(UnevaluatedOutputEnvironmentVariable_)' != ''">$(UpperCombinedReverseEnvVars_.IndexOf(';', $([MSBuild]::Add($(CombinedEnvVarEvalEqualsPosition_), 1))))</CombinedEnvVarEvalSemicolonPosition_>
    <CombinedEnvVarEvalSemicolonPosition_ Condition="'$(CombinedEnvVarEvalSemicolonPosition_)' != '' and $(CombinedEnvVarEvalSemicolonPosition_) != -1">$([MSBuild]::Subtract($(CombinedEnvVarEvalSemicolonPosition_), 1))</CombinedEnvVarEvalSemicolonPosition_>
    <CombinedEnvVarEvalSemicolonPosition_ Condition="'$(CombinedEnvVarEvalSemicolonPosition_)' != '' and $(CombinedEnvVarEvalSemicolonPosition_) == -1">$([MSBuild]::Subtract($(CombinedReverseEnvVars_.Length), 1))</CombinedEnvVarEvalSemicolonPosition_>
    <ExpandedRealEnvironmentVariable_ Condition="'$(CombinedEnvVarEvalPosition_)' != '' and $(CombinedEnvVarEvalPosition_) > -1 AND  $(CombinedEnvVarEvalEqualsPosition_) > -1">$(CombinedReverseEnvVars_.SubString($([MSBuild]::Add($(CombinedEnvVarEvalEqualsPosition_), 1)), $([MSBuild]::Subtract($(CombinedEnvVarEvalSemicolonPosition_), $(CombinedEnvVarEvalEqualsPosition_)))))</ExpandedRealEnvironmentVariable_>
    <ExpandedRealEnvironmentVariable_ Condition="'$(ExpandedRealEnvironmentVariable_)' == ''">$([System.Environment]::GetEnvironmentVariable($(UnevaluatedOutputEnvironmentVariable_)))</ExpandedRealEnvironmentVariable_>
    <UnevaluatedOutputEnvironmentVariableTrailer_ Condition="'$(ExpandedRealEnvironmentVariable_)' == '' and !$(ExpandedRealEnvironmentVariable_.EndsWith('\'))">\$(UnevaluatedOutputEnvironmentVariableTrailer_)</UnevaluatedOutputEnvironmentVariableTrailer_>
    <OutputPath Condition="'$(ExpandedRealEnvironmentVariable_)' != ''">$(ExpandedRealEnvironmentVariable_)$(UnevaluatedOutputEnvironmentVariableTrailer_)</OutputPath>
    <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)</OutDir>
  </PropertyGroup>

  <PropertyGroup Condition="'$(UnevaluatedOutputPath)' == ''">
    <UnevaluatedOutputPath Condition="'$(UnevaluatedOutputPath)' == ''">$(OutputPath)$(UnevaluatedOutputEnvironmentVariableTrailer_)</UnevaluatedOutputPath>
  <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)$(UnevaluatedOutputEnvironmentVariableTrailer_)</OutDir>
  </PropertyGroup>

  <PropertyGroup>
    <UseExistingRepository_ Condition="'$(UseExistingRepository)' == ''">false</UseExistingRepository_>
    <UseExistingRepository_ Condition="'$(UseExistingRepository)' != ''">$(UseExistingRepository)</UseExistingRepository_>
  </PropertyGroup>

  <ItemGroup>
    <_RPSTimestampFile Include="$(IntermediateOutputPath)\rpsbuild.timestamp" />
  </ItemGroup>

  <Target
        Name="ISMExtensionFixup">
    <SynergyTasks.ISMExtensioner
			InputName ="$(MOutputName)"
			>
      <Output TaskParameter="OutputName" PropertyName="MOutputName" />
      <Output TaskParameter="OutputName2" PropertyName="MOutputName2" />
    </SynergyTasks.ISMExtensioner>

    <SynergyTasks.ISMExtensioner
			InputName ="$(TOutputName)"
			>
      <Output TaskParameter="OutputName" PropertyName="TOutputName" />
      <Output TaskParameter="OutputName2" PropertyName="TOutputName2" />
    </SynergyTasks.ISMExtensioner>
    <PropertyGroup>
    <CombinedMOutputName>$(OutputPath)\$(MOutputName)</CombinedMOutputName>
    <CombinedMOutputName Condition="$(UseExistingRepository_)">$(MOutputName)</CombinedMOutputName>
      
    <CombinedMOutputName2>$(OutputPath)\$(MOutputName2)</CombinedMOutputName2>
    <CombinedMOutputName2 Condition="$(UseExistingRepository_)">$(MOutputName2)</CombinedMOutputName2>
      
    <CombinedTOutputName>$(OutputPath)\$(TOutputName)</CombinedTOutputName>
    <CombinedTOutputName Condition="$(UseExistingRepository_)">$(TOutputName)</CombinedTOutputName>
      
    <CombinedTOutputName2>$(OutputPath)\$(TOutputName2)</CombinedTOutputName2>
    <CombinedTOutputName2 Condition="$(UseExistingRepository_)">$(TOutputName2)</CombinedTOutputName2>

    <CombinedMIntermediateOutputName>$(IntermediateOutputPath)\$(MOutputName)</CombinedMIntermediateOutputName>
    <CombinedMIntermediateOutputName Condition="$(UseExistingRepository_)">$(IntermediateOutputPath)\$(MOutputName)</CombinedMIntermediateOutputName>

    <CombinedTIntermediateOutputName>$(IntermediateOutputPath)\$(TOutputName)</CombinedTIntermediateOutputName>
    <CombinedTIntermediateOutputName Condition="$(UseExistingRepository_)">$(IntermediateOutputPath)\$(TOutputName)</CombinedTIntermediateOutputName>

    <CombinedMIntermediateOutputName2>$(IntermediateOutputPath)\$(MOutputName2)</CombinedMIntermediateOutputName2>
    <CombinedMIntermediateOutputName2 Condition="$(UseExistingRepository_)">$(IntermediateOutputPath)\$(MOutputName2)</CombinedMIntermediateOutputName2>

    <CombinedTIntermediateOutputName2>$(IntermediateOutputPath)\$(TOutputName2)</CombinedTIntermediateOutputName2>
    <CombinedTIntermediateOutputName2 Condition="$(UseExistingRepository_)">$(IntermediateOutputPath)\$(TOutputName2)</CombinedTIntermediateOutputName2>
  </PropertyGroup>

  </Target>

  <Target Name="GetNativeManifest" />
    
  <Target
      Name="GetTargetPath"
      Returns="@(OutputItemType)">
    
  </Target>

  <Target
    Name="CompileDetection"
    Inputs="$(MSBuildAllProjects);
            @(Compile);"
      Outputs="$(NonExistentFile);
              @(CustomAdditionalCompileOutputs)"
      >

    <CreateProperty Value="true">
      <Output TaskParameter="ValueSetByTask"
        PropertyName="CompilationDetected" />
    </CreateProperty>
  </Target>

  <Target Name="GetTargetFrameworks"
         Returns="@(_ThisProjectBuildMetadata)">
    <ItemGroup>
      <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
      </_ThisProjectBuildMetadata>
    </ItemGroup>
  </Target>
  <Target Name="GetTargetFrameworkProperties" />
  <Target Name="GetFrameworkPaths" />
  <Target Name="GetPackagingOutputs" />
  <Target Name="GetRepositoryMetadata"
          DependsOnTargets="ISMExtensionFixup"
          Returns="$(RepositoryReference)">
    <PropertyGroup>
        <RepositoryReference>
          $(CombinedTOutputName);
          $(CombinedMOutputName);
          $(CombinedTOutputName2);
          $(CombinedMOutputName2)
        </RepositoryReference>
    </PropertyGroup>
  </Target>
  <Target Name="GetCopyToOutputDirectoryItems" />
  
  <Target Name="BeforeBuild">
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)"/>
  </Target>
  <Target Name="AfterBuild"/>
  <Target
      Name="CopyFilesToOutputDirectory"
      Condition=" !$(UseExistingRepository_) " 
      DependsOnTargets="_CheckForCompileOutputs;CoreCompile">

    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateHardLinksForCopyFilesToOutputDirectoryIfPossible>
      <CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible>
    </PropertyGroup>

    <PropertyGroup>
      <CopyBuildOutputToOutputDirectory Condition="'$(CopyBuildOutputToOutputDirectory)'==''">true</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory Condition="'$(CopyOutputSymbolsToOutputDirectory)'==''">true</CopyOutputSymbolsToOutputDirectory>
    </PropertyGroup>

    <!-- Copy the build product (.dll or .exe). -->
    <Copy
        SourceFiles="$(CombinedMIntermediateOutputName);$(CombinedMIntermediateOutputName2);$(CombinedTIntermediateOutputName);$(CombinedTIntermediateOutputName2)"
        DestinationFolder="$(OutDir)"
        SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
        Retries="$(CopyRetryCount)"
        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
        UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
            >

      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

    </Copy>

    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; @(MainAssembly->'%(FullPath)')" Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)'!='true'" />

  </Target>

  <Target
      Name="_CheckForCompileOutputs">

    <!--Record the main compile outputs.-->
    <ItemGroup>
      <FileWrites Include="$(CombinedMIntermediateOutputName)" Condition="Exists('$(CombinedMIntermediateOutputName)')"/>
      <FileWrites Include="$(CombinedTIntermediateOutputName)" Condition="Exists('$(CombinedTIntermediateOutputName)')"/>
      <FileWrites Include="$(CombinedMIntermediateOutputName2)" Condition="Exists('$(CombinedMIntermediateOutputName2)')"/>
      <FileWrites Include="$(CombinedTIntermediateOutputName2)" Condition="Exists('$(CombinedTIntermediateOutputName2)')"/>
    </ItemGroup>
  </Target>

  <!--
    ============================================================
                                        Rebuild

    Delete all intermediate and final build outputs, and then build the project from scratch.
    ============================================================
    -->
  <PropertyGroup>

    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' != ''">$(MSBuildProjectDefaultTargets)</_ProjectDefaultTargets>
    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' == ''">Build</_ProjectDefaultTargets>

    <RebuildDependsOn>
      Clean;
      $(_ProjectDefaultTargets);
    </RebuildDependsOn>

    <RebuildDependsOn Condition=" '$(MSBuildProjectDefaultTargets)' == 'Rebuild' " >
      Clean;
      Build;
    </RebuildDependsOn>
  </PropertyGroup>

  <Target
      Name="Rebuild"
      Condition=" '$(_InvalidConfigurationWarning)' != 'true' "
      DependsOnTargets="$(RebuildDependsOn)"
      Returns="$(TargetPath)"/>

  <PropertyGroup>
    <CoreCleanDependsOn></CoreCleanDependsOn>
  </PropertyGroup>
   <Target
      Name="Clean" />
  <Target
      Name="Real_Clean"
      DependsOnTargets="$(CoreCleanDependsOn)">

    <!-- First clean any explicitly specified cleanable files.
             Declare items of this type if you want Clean to delete them. -->
    <Delete
        Files="@(Clean);@(_RPSTimestampFile)"
        TreatErrorsAsWarnings="true"/>

    <!-- Read in list of files that were written to disk in past builds. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanPriorFileWrites"/>
    </ReadLinesFromFile>

    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInOutput"/>
    </FindUnderPath>

    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)"    Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInIntermediate"/>
    </FindUnderPath>

    <!-- Delete those files. -->
    <Delete
        Files="@(_CleanPriorFileWritesInOutput);@(_CleanPriorFileWritesInIntermediate)"
        TreatErrorsAsWarnings="true">

      <Output TaskParameter="DeletedFiles" ItemName="_CleanPriorFileWritesDeleted"/>

    </Delete>

    <!-- Create a list of everything that wasn't deleted. -->
    <ItemGroup>
      <_CleanRemainingFileWritesAfterClean Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanPriorFileWritesDeleted)"/>
    </ItemGroup>

    <!-- Remove duplicates. -->
    <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterClean)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWrites"/>
    </RemoveDuplicates>

    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)"/>

    <!-- Write new list of current files back to disk. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" Overwrite="true" />

  </Target>


  <!--
    ============================================================
                                        _CleanRecordFileWrites

    Save the list of all files written to disk so that it can be used for "Clean" later.

    Files written in prior builds are not removed from Clean cache.
    ============================================================
    -->
  <Target
       Name="_CleanRecordFileWrites"
       DependsOnTargets="_CleanGetCurrentAndPriorFileWrites">

    <!--
        Merge list of files from prior builds with the current build and then
        remove duplicates.
        -->
    <RemoveDuplicates Inputs="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueFileWrites"/>
    </RemoveDuplicates>

    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)"/>

    <!-- Write merged file list back to disk, replacing existing contents. -->
    <WriteLinesToFile
        File="$(IntermediateOutputPath)$(CleanFile)"
        Lines="@(_CleanUniqueFileWrites)"
        Overwrite="true" />

  </Target>

<!--
    ============================================================
                                        _CleanGetCurrentAndPriorFileWrites

    Get the list of files built in the current build and in prior builds.
    ============================================================
    -->
  <Target
       Name="_CleanGetCurrentAndPriorFileWrites"
       DependsOnTargets="_CheckForCompileOutputs">

    <!-- Read the list of files produced by a prior builds from disk. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanUnfilteredPriorFileWrites"/>
    </ReadLinesFromFile>

    <!--
        Subtract any resolved assembly files from *prior* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.
         -->
    <ItemGroup>
      <_CleanPriorFileWrites Include="@(_CleanUnfilteredPriorFileWrites)" />
    </ItemGroup>

    <!--
        Of shareable files, keep only those that are in the project's directory.
        We never clean shareable files outside of the project directory because
        the build may be to a common output directory and other projects may need
        them.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
        -->
    <FindUnderPath Path="$(MSBuildProjectDirectory)" Files="@(FileWritesShareable)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="FileWrites"/>
    </FindUnderPath>

    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInOutput"/>
    </FindUnderPath>

    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInIntermediate"/>
    </FindUnderPath>

    <!--
        Subtract any resolved assembly files from *current* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
         -->
    <ItemGroup>
      <_CleanCurrentFileWritesWithNoReferences Include="@(_CleanCurrentFileWritesInOutput);@(_CleanCurrentFileWritesInIntermediate)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)"/>
    </ItemGroup>

    <!-- Remove duplicates from files produced in this build. -->
    <RemoveDuplicates Inputs="@(_CleanCurrentFileWritesWithNoReferences)" >
      <Output TaskParameter="Filtered" ItemName="_CleanCurrentFileWrites"/>
    </RemoveDuplicates>

  </Target>

  <Target
        Name="ExistingRpsBuild"
        Condition="$(UseExistingRepository_)"
        Returns=""
        Inputs="$(CombinedMOutputName);$(CombinedTOutputName);$(CombinedMOutputName2);$(CombinedTOutputName2)"
        Outputs="@(_RPSTimestampFile)"
        DependsOnTargets="ISMExtensionFixup;$(CoreCompileDependsOn)">

    <SynergyTasks.RPS
      IntermediateOutputPath="$(IntermediateOutputPath)"
      OutputPath="$(OutputPath)"
      SchemaFiles ="@(Compile)"
      DisableRebuild="$(UseExistingRepository_)"
      MOutputName ="$(MOutputName)"
      TOutputName="$(TOutputName)"
      MOutputName2 ="$(MOutputName2)"
      TOutputName2="$(TOutputName2)"
      OutputFiles="@(CustomAdditionalCompileOutputs)"
      EnvironmentVars="$(CombinedEnvVars)"/>

  </Target>

  <Target
        Name="CoreCompile"
        Returns=""
        Condition="!$(UseExistingRepository_)"
        Inputs="$(MSBuildProjectFile);@(Compile);@(Content)"
        Outputs="$(CombinedMIntermediateOutputName);$(CombinedMIntermediateOutputName2);$(CombinedTIntermediateOutputName);$(CombinedTIntermediateOutputName2);$(CombinedMOutputName);$(CombinedTOutputName)"
        DependsOnTargets="ISMExtensionFixup;$(CoreCompileDependsOn)">    
    
    <SynergyTasks.RPS
      IntermediateOutputPath="$(IntermediateOutputPath)"
      OutputPath="$(OutputPath)"
      SchemaFiles ="@(Compile)"
      DisableRebuild="$(UseExistingRepository_)"
      MOutputName ="$(MOutputName)"
      TOutputName="$(TOutputName)"
      MOutputName2 ="$(MOutputName2)"
      TOutputName2="$(TOutputName2)"
      OutputFiles="@(CustomAdditionalCompileOutputs)"
      EnvironmentVars="$(CombinedEnvVars)"
      TargetISAM4="$(TargetISAM4)"/>

  </Target>
  <PropertyGroup>
    <PreBuildEventTarget Condition="'$(RunPreBuildEvent)' == 'Always'">PreBuildEvent</PreBuildEventTarget>
    <PreBuildEventTarget Condition="'$(RunPreBuildEvent)' != 'Always'">PreBuildEventWithInputs</PreBuildEventTarget>
    <BuildDependsOn>
      BeforeBuild;
      $(PreBuildEventTarget);
      CoreCompile;
      ExistingRpsBuild;
      CopyFilesToOutputDirectory;
      _CleanRecordFileWrites;
      AfterBuild;
      PostBuildEvent;
    </BuildDependsOn>
  </PropertyGroup>

  <Target
      Name="Build"
      Condition="'$(_InvalidConfigurationWarning)' != 'true'"
      DependsOnTargets="$(BuildDependsOn)"
      Returns="$(TargetPath)">
      <OnError ExecuteTargets="PostBuildEvent" Condition="'$(RunPostBuildEvent)' == 'Always'"/>
  </Target>
  
  <Target
      Name="PreBuildEvent"
      Condition="'$(PreBuildEvent)'!=''"
      DependsOnTargets="$(PreBuildEventDependsOn)">
    <MakeDir Condition="!Exists('$(OutDir)')" Directories="$(OutDir)" />
    <Exec WorkingDirectory="$(OutDir)" Command="$(PreBuildEvent)" />
  </Target>
  
  <Target Name="EvaluatePreBuild">
    <PropertyGroup>
      <PreBuildOutputs Condition="'$(RunPreBuildEvent)' != 'Always'">$(CombinedMOutputName)</PreBuildOutputs>
    </PropertyGroup>
  </Target>
  
  <PropertyGroup>
    <PreBuildEventDependsOn>ISMExtensionFixup;EvaluatePreBuild</PreBuildEventDependsOn>
    <PreBuildInputs Condition="'$(RunPreBuildEvent)' == 'Compile'">@(Compile)</PreBuildInputs>
    <PreBuildInputs Condition="'$(RunPreBuildEvent)' == 'Content'">@(Content)</PreBuildInputs>
    <PreBuildInputs Condition="'$(RunPreBuildEvent)' == 'Both'">@(Compile);@(Content)</PreBuildInputs>
  </PropertyGroup>
  <Target
      Name="PreBuildEventWithInputs"
      Condition="'$(PreBuildEvent)'!=''"
      DependsOnTargets="$(PreBuildEventDependsOn)"
      Inputs="$(PreBuildInputs)"
      Outputs="$(PreBuildOutputs)">
    <MakeDir Condition="!Exists('$(OutDir)')" Directories="$(OutDir)" />
    <Exec WorkingDirectory="$(OutDir)" Command="$(PreBuildEvent)" />
  </Target>
  
  <PropertyGroup>
    <PostBuildEventDependsOn></PostBuildEventDependsOn>
  </PropertyGroup>
  <Target
      Name="PostBuildEvent"
      Condition="'$(PostBuildEvent)' != ''"
      DependsOnTargets="$(PostBuildEventDependsOn)">
    <MakeDir Condition="!Exists('$(OutDir)')" Directories="$(OutDir)" />
    <Exec WorkingDirectory="$(OutDir)" Command="$(PostBuildEvent)" />
  </Target>

  <Target
      Name="PrepareForBuild">

    <!-- Create the directories for intermediate and final build products, and any other arbitrary directories. -->
    <!-- We are going to continue on error here so that if the tree is read only we will still get intellisense -->
    <MakeDir Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)');@(CreateDirectory)" ContinueOnError="True"/>
  </Target>

  <!--
    ============================================================
                                        GetCopyToPublishDirectoryItems

    Default implementation of GetCopyToPublishDirectoryItems for projects that do not
    use Microsoft.NET.Sdk. It simply returns whatever GetCopyToOutputDirectoryItems
    does with CopyToPublishDirectory implied  by CopyToOutputDirectory, which is the
    same as Microsoft.NET.Sdk default when its CopyToPublishDirectory is not used.

    Microsoft.NET.Sdk projects  will override this to allow the publish output to be
    customized independently from the build output.

    Having a default implementation here allows the Microsoft.NET.Sdk Publish target
    to work when a Microsoft.NET.Sdk-based project references a non-Microsoft.NET.Sdk-based
    project.
    ============================================================
    -->
    <Target
      Name="GetCopyToPublishDirectoryItems"
      DependsOnTargets="GetCopyToOutputDirectoryItems"
      Returns="@(AllPublishItemsFullPathWithTargetPath)">

    <ItemGroup>
      <AllPublishItemsFullPathWithTargetPath Include="@(AllItemsFullPathWithTargetPath)">
        <CopyToPublishDirectory>%(CopyToOutputDirectory)</CopyToPublishDirectory>
      </AllPublishItemsFullPathWithTargetPath>
    </ItemGroup>
  </Target>

  <Target Name="GetPrototypes" DependsOnTargets="$(GetPrototypesDependsOn)" Returns="@(_PrototypeFile)">
  </Target>

  <!-- Import NuGet.targets (required for GetReferenceNearestTargetFrameworkTask and used for Restore functionality) -->
  <PropertyGroup>
    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$([MSBuild]::IsRunningFromVisualStudio())'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'==''">$(MSBuildToolsPath)\NuGet.targets</NuGetRestoreTargets>
  </PropertyGroup>
  <Import Project="$(NuGetRestoreTargets)" />
</Project>